package lock

/*
摘抄自作者blog：
*/

/*
ConcurrentMap 可以保证对单个 key 操作的并发安全性，但是仍然无法满足需求:
	Incr 命令需要完成: 读取 -> 做加法 -> 写入 (三步操作如何原子？)
	MSETNX 命令当且仅当所有给定键都不存在时所有给定键设置值, 因此我们需要锁定所有给定的键直到完成所有键的检查和设置

因此需要实现 db.Locker 用于锁定一个或一组 key 并在我们需要的时候释放锁

实现 db.Locker 最直接的想法是使用一个 map[string]*sync.RWMutex,
加锁过程分为两步: 初始化对应的锁 -> 加锁， 解锁过程也分为两步: 解锁 -> 释放对应的锁，但是存在问题：
				时间			协程A					协程B
			1		locker["a"].Unlock()
			2								locker["a"] = &sync.RWMutex{}
			3								delete(locker["a"])
			4		locker["a"].Lock()
由于 t3 时协程B释放了锁，t4 时协程A试图加锁会失败。

若我们在解锁时不释放锁就可以避免该异常的发生，但是每个曾经使用过的锁都无法释放从而造成严重的内存泄露。

我们注意到哈希表的长度远少于可能的键的数量，反过来说多个键可以共用一个哈希槽。
若我们不为单个键加锁而是为它所在的哈希槽加锁，因为哈希槽的数量非常少即使不释放锁也不会占用太多内存。

所以其实 lock 是对 key进行另一次hash，然后再上锁。hashCode 啥的都由 lock 重新定，然后key再分配，
因为无需存储数据，所以可以让多个key分配到同一个锁上，这样就节约了资源，非常好用昂。
*/
